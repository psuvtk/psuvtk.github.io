[{"categories":null,"content":"2025 里程碑: 体脂降低20% 体脂降低18% 体脂降低16% 体脂降低14% 悬垂直举腿 [20250225] 支架L支撑10s 支架L支撑20s 支架L支撑30s 支架L支撑45s 支架L支撑60s 低团摇摆 低团3s 低团5s 低团10s 低团15s 低团20s 低团30s 低团40s 低团45s 低团60s 前水平左腿 前水平右腿 前水平 分腿俄挺 并腿俄挺 信条: 这一次我不会轻易放弃 健身等同于在休息 L支撑之前一定要压腿拉伸股四 ","date":"2025-02-25","objectID":"/posts/37836c6/:0:1","tags":null,"title":"健身笔记","uri":"/posts/37836c6/"},{"categories":null,"content":"20250225 饮食： 中午辣椒炒肉+豆腐，晚上无，回家练完饿的没忍住吃了合味道 体脂: 三星手表 21% 今日训练: 标准俯卧撑: 30 16 16 窄距俯卧撑: 15 坐姿下压: 16 12 12 (二头爆炸) 单杠悬垂直举腿: 10 单杠悬垂区举腿: 10 单杠悬垂: 45s 30s 30s 30s 35s(力竭) 30s (屈桡肌充血爆炸、握力++) 飘窗屈腿L支撑: 30s 30s 30s 俯卧交替摸肩: 60s 90s 支架L支撑10s PR: 标准俯卧撑: 30 反手引体: 5 阶段目标PR: 正反手引体：10 俯卧撑: 30 * 2 单杠悬垂: 1min * 2 ","date":"2025-02-25","objectID":"/posts/37836c6/:0:2","tags":null,"title":"健身笔记","uri":"/posts/37836c6/"},{"categories":null,"content":"202502 突然解锁界面L支撑，虽然坚持不了3s ","date":"2025-02-25","objectID":"/posts/37836c6/:0:3","tags":null,"title":"健身笔记","uri":"/posts/37836c6/"},{"categories":null,"content":"20241205 宽距俯卧撑 8+ 12+ ","date":"2025-02-25","objectID":"/posts/37836c6/:0:4","tags":null,"title":"健身笔记","uri":"/posts/37836c6/"},{"categories":null,"content":"动作 ","date":"2025-02-25","objectID":"/posts/37836c6/:1:0","tags":null,"title":"健身笔记","uri":"/posts/37836c6/"},{"categories":null,"content":"腹部 T0悬垂举腿 ","date":"2025-02-25","objectID":"/posts/37836c6/:1:1","tags":null,"title":"健身笔记","uri":"/posts/37836c6/"},{"categories":null,"content":"二头肌 T2服务生托举、T2引体向上、T1杠铃弯举、T0哑铃交替弯举 ","date":"2025-02-25","objectID":"/posts/37836c6/:1:2","tags":null,"title":"健身笔记","uri":"/posts/37836c6/"},{"categories":null,"content":"三头肌 窄距卧推、绳索下拉、双杠臂屈伸、俯卧撑 ","date":"2025-02-25","objectID":"/posts/37836c6/:1:3","tags":null,"title":"健身笔记","uri":"/posts/37836c6/"},{"categories":["draft"],"content":"0、因为在某一瞬间我真正感受到了幸福，所以执着于你; 1、把问题抛给对方 2、回忆只是对过去的留恋，而现实才决定会拥有怎样的未来 3、凡事自己不愿意做的事情，都会推给别人做决定 4、房子老婆孩子，少选一个都会幸福很多 5、死亡不是终点，遗憾才是 6、很多年轻女性默认一点，自己是无需为自己的未来负责的，不管是父母、亲戚、伴侣还是政府，但是总得有一个人为自己的未来兜底。 7、之所以善待未婚女性，是因为她们都是一个潜在的母亲 8、女性福利实际上是母亲福利。 9、任何你想禁止的东西都有它存在的意义 10、挣钱少的依赖方不要想拿捏我。 11、位置不同，少言为贵；认知不同，不争不辩；三观不合，浪费口舌。 12、要什么避风港，钞票才是梦想。what do you want safe haven, money is the dream. 13、房子是伪装成资产的负债。 14、买房是给房企续命。 15、产权70年，主体设计寿命50年，金融属性还剩多少？20年？透支无产阶级全家存款和自己的余生价值。农民进城缴纳的投名状。 ","date":"2025-02-12","objectID":"/posts/4ec752e/:0:0","tags":["draft"],"title":"想法","uri":"/posts/4ec752e/"},{"categories":["draft"],"content":" 接口 创建 删除 出队 入队 | 查询 ||| ","date":"2024-12-04","objectID":"/posts/8e0d8d2/:1:0","tags":["draft"],"title":"Queue Intf","uri":"/posts/8e0d8d2/"},{"categories":["工程"],"content":"进阶技巧 碰到就学习，有用就记住 ","date":"2024-10-07","objectID":"/posts/6f93fa5/:1:0","tags":["cmake"],"title":"CMake备忘","uri":"/posts/6f93fa5/"},{"categories":["工程"],"content":"FetchContent https://cmake.org/cmake/help/latest/module/FetchContent.html ","date":"2024-10-07","objectID":"/posts/6f93fa5/:1:1","tags":["cmake"],"title":"CMake备忘","uri":"/posts/6f93fa5/"},{"categories":["工程"],"content":"Modern CMake https://hsf-training.github.io/hsf-training-cmake-webpage/aio/index.html https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html ","date":"2024-10-07","objectID":"/posts/6f93fa5/:2:0","tags":["cmake"],"title":"CMake备忘","uri":"/posts/6f93fa5/"},{"categories":["工程"],"content":"常用 cmake_minimum_required(VERSION 3.11) project(ProjectName) target_link_libraries(ProjectName libarchive) target_include_directories(ProjectName ${CMAKE_SOURCE_DIR}/include) # 链接静态库 target_link_libraries(csgo ${CMAKE_SOURCE_DIR}/libarchive_static.a ) # 安装 ","date":"2024-10-07","objectID":"/posts/6f93fa5/:3:0","tags":["cmake"],"title":"CMake备忘","uri":"/posts/6f93fa5/"},{"categories":["工程"],"content":"启动构建 统一的构建命令 cmake -S . -B build cmake --build build --target install old style mkdir -p build cd build cmake .. make make install ","date":"2024-10-07","objectID":"/posts/6f93fa5/:4:0","tags":["cmake"],"title":"CMake备忘","uri":"/posts/6f93fa5/"},{"categories":[""],"content":"在hugo生成的根目录部署发现会出问题，但是部署public目录就是正常的 那么每次生成的时候将public目录内容进行git commit, 然后推送到远端 原始内容怎么办呢？ 在public目录下创建 repo目录, 然后将外层目录拷贝到repo目录推送到远端； 更换电脑后，克隆仓库，然后将public/repo目录内容拷贝到外层; ","date":"2024-10-07","objectID":"/posts/7398491/:0:0","tags":["BLOG","HUGO"],"title":"HUGO 本博客部署","uri":"/posts/7398491/"},{"categories":["c-lang"],"content":"大小端 Data: 0x AB CD 12 34 Big Endian: AB CD 12 34 Little Endian: 34 12 CD AB ","date":"2024-09-28","objectID":"/posts/419e98c/:1:0","tags":["结构体位域","大小端"],"title":"结构体位域与大小端","uri":"/posts/419e98c/"},{"categories":["c-lang"],"content":"结构体位域 首先看相同的结构体定义在不同大小端机器上的表现; struct S { uint32_t A : 5; uint32_t B : 6; uint32_t C : 7; uint32_t D : 8; uint32_t E : 6; }; 如果上述结构体位域用于小端机器，则表示的数据和存储格式分别如下: 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 E E E E E E D D D D D D D D C C C C C C C B B B B B B A A A A A Little Endian: | Byte0 | Byte1 | Byte2 | Byte2 | 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 B B B A A A A A C C C C C B B B D D D D D D C C E E E E E E D D 如果上述结构体位域用于大端机器，则表示的数据和存储格式分别如下： 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 A A A A A B B B B B B C C C C C C C D D D D D D D D E E E E E E Big Endian : | Byte0 | Byte1 | Byte2 | Byte2 | 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 A A A A A B B B B B B C C C C C C C D D D D D D D D E E E E E E ","date":"2024-09-28","objectID":"/posts/419e98c/:2:0","tags":["结构体位域","大小端"],"title":"结构体位域与大小端","uri":"/posts/419e98c/"},{"categories":["c-lang"],"content":"实例 然后看相同的格式如何在不同的大小端机器上面定义, 此处用IPv4报文头格式举例（一般从左到右标注MSB-\u003eLSB, 此处可以理解为从左到右为数据包BIT流到达的顺序）： 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Version| IHL |Type of Service| Total Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Identification |Flags| Fragment Offset | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Time to Live | Protocol | Header Checksum | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Source Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Destination Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Options | Padding | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Example Internet Datagram Header Figure 4. ","date":"2024-09-28","objectID":"/posts/419e98c/:3:0","tags":["结构体位域","大小端"],"title":"结构体位域与大小端","uri":"/posts/419e98c/"},{"categories":["c-lang"],"content":"小端 如果是小端机器，则需要使用如下定义: struct { uint32_t version : 4; uint32_t ihl : 4; uint32_t type_of_service : 8; uint32_t total_length : 16; ... }; 或者 struct { uint8_t version : 4; uint8_t ihl : 4; uint8_t type_of_service : 8; uint16_t total_length : 16; ... }; 或者(Linux内核中 iphdr定义) struct { uint8_t version : 4, ihl : 4; uint8_t type_of_service : 8; uint16_t total_length : 16; ... }; ","date":"2024-09-28","objectID":"/posts/419e98c/:3:1","tags":["结构体位域","大小端"],"title":"结构体位域与大小端","uri":"/posts/419e98c/"},{"categories":["c-lang"],"content":"大端 如果是大端机器，则需要使用如下定义: struct { uint32_t total_length : 16; uint32_t type_of_service : 8; uint32_t ihl : 4; uint32_t version : 4; ... }; ","date":"2024-09-28","objectID":"/posts/419e98c/:3:2","tags":["结构体位域","大小端"],"title":"结构体位域与大小端","uri":"/posts/419e98c/"},{"categories":["c-lang"],"content":"在线测试 可以在在线编译网站上面测试一下: /****************************************************************************** Online C Compiler. Code, Compile, Run and Debug C program online. Write your code in this editor and press \"Run\" button to compile and execute it. *******************************************************************************/ #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e struct A { uint32_t version : 4; uint32_t ihl : 4; uint32_t type_of_service : 8; uint32_t total_length : 16; }; struct B { uint8_t version : 4; uint8_t ihl : 4; uint8_t type_of_service : 8; uint16_t total_length : 16; }; struct C { uint8_t version : 4, ihl : 4; uint8_t type_of_service : 8; uint16_t total_length : 16; }; int main() { struct A a = {0}; struct B b = {0}; struct C c = {0}; a.version = 1; a.ihl = 2; a.type_of_service = 0x33; a.total_length = 0x4444; b.version = 1; b.ihl = 2; b.type_of_service = 0x33; b.total_length = 0x4444; c.version = 1; c.ihl = 2; c.type_of_service = 0x33; c.total_length = 0x4444; printf(\"struct A: 0x%08x\\n\", *(uint32_t*)\u0026a); printf(\"struct B: 0x%08x\\n\", *(uint32_t*)\u0026b); printf(\"struct C: 0x%08x\\n\", *(uint32_t*)\u0026c); return 0; } 预期输出: struct A: 0x44443321 struct B: 0x44443321 struct C: 0x44443321 ","date":"2024-09-28","objectID":"/posts/419e98c/:3:3","tags":["结构体位域","大小端"],"title":"结构体位域与大小端","uri":"/posts/419e98c/"},{"categories":["draft"],"content":"MAC 报文格式 ","date":"2024-09-04","objectID":"/posts/dced61b/:1:0","tags":["draft"],"title":"MAC报文格式与LSW原理","uri":"/posts/dced61b/"},{"categories":["draft"],"content":"Ethernet 帧格式 ","date":"2024-09-04","objectID":"/posts/dced61b/:1:1","tags":["draft"],"title":"MAC报文格式与LSW原理","uri":"/posts/dced61b/"},{"categories":["draft"],"content":"Ethernet II 帧格式 Ethernet II 帧格式 ","date":"2024-09-04","objectID":"/posts/dced61b/:1:2","tags":["draft"],"title":"MAC报文格式与LSW原理","uri":"/posts/dced61b/"},{"categories":["draft"],"content":"VLAN帧格式 IEEE 802.1Q标准对Ethernet帧格式进行了修改，在源MAC地址字段和协议类型字段之间加入4字节的802.1Q Tag。 VLAN帧格式 ","date":"2024-09-04","objectID":"/posts/dced61b/:1:3","tags":["draft"],"title":"MAC报文格式与LSW原理","uri":"/posts/dced61b/"},{"categories":["draft"],"content":"LSW原理 ","date":"2024-09-04","objectID":"/posts/dced61b/:2:0","tags":["draft"],"title":"MAC报文格式与LSW原理","uri":"/posts/dced61b/"},{"categories":["draft"],"content":"参考 报文格式地图 ","date":"2024-09-04","objectID":"/posts/dced61b/:3:0","tags":["draft"],"title":"MAC报文格式与LSW原理","uri":"/posts/dced61b/"},{"categories":["Linux"],"content":"RT调度与完全公平调度 引入多核的话事情会变得复杂起来，先从简单的场景入手 ","date":"2024-08-31","objectID":"/posts/0ec2c86/:1:0","tags":["调度","SCHED_FIFO","SCHED_RR","ftrace"],"title":"图解Linux系统RT调度(SCHED_FIFO与SCHED_RR)","uri":"/posts/0ec2c86/"},{"categories":["Linux"],"content":"SCHED_FIFO 调度 那么SCHED_FIFO是否可以一直占用CPU？答案是否定的。 在单核系统中，如果允许SCHED_FIFO任务一直占用CPU不释放，则普通任务永远得不到调度; ","date":"2024-08-31","objectID":"/posts/0ec2c86/:2:0","tags":["调度","SCHED_FIFO","SCHED_RR","ftrace"],"title":"图解Linux系统RT调度(SCHED_FIFO与SCHED_RR)","uri":"/posts/0ec2c86/"},{"categories":["Linux"],"content":"调度轨迹抓取及可视化工具 ","date":"2024-08-31","objectID":"/posts/0ec2c86/:3:0","tags":["调度","SCHED_FIFO","SCHED_RR","ftrace"],"title":"图解Linux系统RT调度(SCHED_FIFO与SCHED_RR)","uri":"/posts/0ec2c86/"},{"categories":["Linux"],"content":"调度轨迹抓取脚本 #!/bin/bash echo \"\" \u003e /sys/kernel/tracing/trace echo 1 \u003e /sys/kernel/tracing/events/sched/enable echo 80920 \u003e /sys/kernel/tracing/buffer_size_kb echo 1 \u003e /sys/kernel/tracing/tracing_on # 执行需要抓取调度轨迹的程序 # ./a.out echo 0 \u003e /sys/kernel/tracing/tracing_on cat /sys/kernel/tracing/trace \u003e /root/trace_out ","date":"2024-08-31","objectID":"/posts/0ec2c86/:3:1","tags":["调度","SCHED_FIFO","SCHED_RR","ftrace"],"title":"图解Linux系统RT调度(SCHED_FIFO与SCHED_RR)","uri":"/posts/0ec2c86/"},{"categories":["Linux"],"content":"可视化工具 Huawei SmartPerf ","date":"2024-08-31","objectID":"/posts/0ec2c86/:3:2","tags":["调度","SCHED_FIFO","SCHED_RR","ftrace"],"title":"图解Linux系统RT调度(SCHED_FIFO与SCHED_RR)","uri":"/posts/0ec2c86/"},{"categories":["Linux"],"content":"实验 Tested on 4Core@Ubuntu-24.04-VirtualBox ","date":"2024-08-31","objectID":"/posts/0ec2c86/:4:0","tags":["调度","SCHED_FIFO","SCHED_RR","ftrace"],"title":"图解Linux系统RT调度(SCHED_FIFO与SCHED_RR)","uri":"/posts/0ec2c86/"},{"categories":["Linux"],"content":"单核实验 实验: 2个SCHED_RR任务, 均绑定到核3 实验预期: 实验: 2个SCHED_FIFO任务, 均绑定到核3 实验: 1个SCHED_RR任务, 1个SCHED_FIFO任务, 均绑定到核3 实验代码 #define _GNU_SOURCE #include \u003csched.h\u003e #include \u003cstdint.h\u003e #include \u003cpthread.h\u003e #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \"time.h\" void payload(int s) { int a,b; for (uint64_t i = 0; i \u003c 100000000 * s; i++ ) { a = b + i; } } void set_affinity(int p) { cpu_set_t cpuset; CPU_ZERO(\u0026cpuset); CPU_SET(p, \u0026cpuset); if (sched_setaffinity(0, sizeof(cpuset), \u0026cpuset)) { printf(\"bind cpu faild\\n\"); } } void* rt_fifo_entry1(void *data) { struct sched_param sp = {0}; sp.sched_priority = 91; // if (sched_setscheduler(0, SCHED_RR, \u0026sp)) { if (sched_setscheduler(0, SCHED_FIFO, \u0026sp)) { printf(\"thread set sched_fifo failed\\n\"); } set_affinity(3); printf(\"thread-1 create, tid: %u\\n\", gettid()); payload(10); } void* rt_fifo_entry2(void *data) { struct sched_param sp = {0}; sp.sched_priority = 91; // if (sched_setscheduler(0, SCHED_RR, \u0026sp)) { if (sched_setscheduler(0, SCHED_FIFO, \u0026sp)) { printf(\"thread set sched_fifo failed\\n\"); } set_affinity(3); printf(\"thread-2 create, tid: %u\\n\", gettid()); payload(10); } int main() { pthread_t t; pthread_create(\u0026t, NULL, rt_fifo_entry2, NULL); pthread_create(\u0026t, NULL, rt_fifo_entry1, NULL); printf(\"main thread: %u\\n\",getpid()); payload(15); struct timespec tv={0}; sched_rr_get_interval(getpid(), \u0026tv); printf(\"sched_rr_interval: %.2lf ms\\n\", tv.tv_sec * 1e6 + tv.tv_nsec / 1e6); printf(\"main thread done, exit\\n\"); return 0; } 管理员可以限制 SCHED_FIFO 带宽，以防止实时应用程序程序员启动对处理器进行单调执行的实时任务。 以下是此策略中使用的一些参数： /proc/sys/kernel/sched_rt_period_us 此参数以微秒为单位定义时间，它被视为处理器带宽的 10%。默认值为 1000000 InventoryServices，或 1 秒。 /proc/sys/kernel/sched_rt_runtime_us 此参数以微秒为单位定义运行实时线程的时间周期。默认值为 950000 μs，即 0.95 秒。 ","date":"2024-08-31","objectID":"/posts/0ec2c86/:4:1","tags":["调度","SCHED_FIFO","SCHED_RR","ftrace"],"title":"图解Linux系统RT调度(SCHED_FIFO与SCHED_RR)","uri":"/posts/0ec2c86/"},{"categories":["Linux"],"content":"多核实验 实验: 2个SCHED_FIFO任务, 均绑定到 实验: 3个SCHED_FIFO任务, 分别绑定1~3核 实验: 2个SCHED_FIFO任务, 均绑定到 ","date":"2024-08-31","objectID":"/posts/0ec2c86/:4:2","tags":["调度","SCHED_FIFO","SCHED_RR","ftrace"],"title":"图解Linux系统RT调度(SCHED_FIFO与SCHED_RR)","uri":"/posts/0ec2c86/"},{"categories":["Linux"],"content":"参考 Linux进程管理 (9)实时调度类分析，以及FIFO和RR对比实验 ","date":"2024-08-31","objectID":"/posts/0ec2c86/:5:0","tags":["调度","SCHED_FIFO","SCHED_RR","ftrace"],"title":"图解Linux系统RT调度(SCHED_FIFO与SCHED_RR)","uri":"/posts/0ec2c86/"},{"categories":["Linux"],"content":"上下文 内核在执行系统调用的时候处于进程上下文 可以睡眠 可以被抢占 —\u003e 需要保证系统是可以重入的 ","date":"2024-08-31","objectID":"/posts/80ff57e/:1:0","tags":["draft","抢占"],"title":"理解Linux内核抢占","uri":"/posts/80ff57e/"},{"categories":["Linux"],"content":"用户态抢占 从中断返回用户空间时 从系统调用返回用户空间时 ","date":"2024-08-31","objectID":"/posts/80ff57e/:2:0","tags":["draft","抢占"],"title":"理解Linux内核抢占","uri":"/posts/80ff57e/"},{"categories":["Linux"],"content":"内核态抢占 时机: 未持有锁 ","date":"2024-08-31","objectID":"/posts/80ff57e/:3:0","tags":["draft","抢占"],"title":"理解Linux内核抢占","uri":"/posts/80ff57e/"},{"categories":["Linux"],"content":"Real-World Problem ","date":"2024-08-31","objectID":"/posts/80ff57e/:4:0","tags":["draft","抢占"],"title":"理解Linux内核抢占","uri":"/posts/80ff57e/"},{"categories":["Linux"],"content":"概念 ","date":"2024-08-31","objectID":"/posts/6a476d5/:1:0","tags":["可重入","线程安全"],"title":"可重入性(Reentrancy)与线程安全(Thread-Safety)","uri":"/posts/6a476d5/"},{"categories":["Linux"],"content":"区别与联系 ","date":"2024-08-31","objectID":"/posts/6a476d5/:2:0","tags":["可重入","线程安全"],"title":"可重入性(Reentrancy)与线程安全(Thread-Safety)","uri":"/posts/6a476d5/"},{"categories":["Linux"],"content":"应用场景 ","date":"2024-08-31","objectID":"/posts/6a476d5/:3:0","tags":["可重入","线程安全"],"title":"可重入性(Reentrancy)与线程安全(Thread-Safety)","uri":"/posts/6a476d5/"},{"categories":["Linux"],"content":"什么时候必须使用 可重入函数？ 在信号处理函数、中断上下文使用的函数，当然是同时在普通上下文使用的函数 ","date":"2024-08-31","objectID":"/posts/6a476d5/:3:1","tags":["可重入","线程安全"],"title":"可重入性(Reentrancy)与线程安全(Thread-Safety)","uri":"/posts/6a476d5/"},{"categories":["Linux"],"content":"什么时候必须使用 线程安全函数？ 线程之间使用共享数据，即存在临界区 ","date":"2024-08-31","objectID":"/posts/6a476d5/:3:2","tags":["可重入","线程安全"],"title":"可重入性(Reentrancy)与线程安全(Thread-Safety)","uri":"/posts/6a476d5/"},{"categories":["Linux"],"content":"改造 ","date":"2024-08-31","objectID":"/posts/6a476d5/:4:0","tags":["可重入","线程安全"],"title":"可重入性(Reentrancy)与线程安全(Thread-Safety)","uri":"/posts/6a476d5/"},{"categories":["Linux"],"content":"如何将函数改造成 可重入函数？ 1、屏蔽信号、中断 2、针对全局变量得使用 3、针对静态变量得使用 3、浮点运算 ","date":"2024-08-31","objectID":"/posts/6a476d5/:4:1","tags":["可重入","线程安全"],"title":"可重入性(Reentrancy)与线程安全(Thread-Safety)","uri":"/posts/6a476d5/"},{"categories":["Linux"],"content":"如何将函数改造成 线程安全函数？ 加锁 ","date":"2024-08-31","objectID":"/posts/6a476d5/:4:2","tags":["可重入","线程安全"],"title":"可重入性(Reentrancy)与线程安全(Thread-Safety)","uri":"/posts/6a476d5/"},{"categories":["Linux"],"content":"参考 ","date":"2024-08-31","objectID":"/posts/6a476d5/:5:0","tags":["可重入","线程安全"],"title":"可重入性(Reentrancy)与线程安全(Thread-Safety)","uri":"/posts/6a476d5/"},{"categories":[null],"content":"今年完成了续签，转岗到新的部门。 8月底开始投入新的事务，投入轻核子系统的能力建设; ","date":"2024-08-31","objectID":"/posts/259c8d3/:0:0","tags":[null],"title":"2024 计划与总结","uri":"/posts/259c8d3/"},{"categories":[null],"content":"工作相关 L2相关业务 xxx融合 ","date":"2024-08-31","objectID":"/posts/259c8d3/:1:0","tags":[null],"title":"2024 计划与总结","uri":"/posts/259c8d3/"},{"categories":[null],"content":"技能提升 TBD: Bootlin相关材料 TBD: SMMU在Linux内核实现与使用 TBD: 抢占 ","date":"2024-08-31","objectID":"/posts/259c8d3/:2:0","tags":[null],"title":"2024 计划与总结","uri":"/posts/259c8d3/"},{"categories":[null],"content":"生活 买车 办理护照 ","date":"2024-08-31","objectID":"/posts/259c8d3/:3:0","tags":[null],"title":"2024 计划与总结","uri":"/posts/259c8d3/"},{"categories":null,"content":" PMBUS 时序被打断 原因：判断写结束使用FIFO为空进行判断，但实际上FIFO为空并不能保证时序完全被打出 正确的方式是使用控制器的BUSY状态进行判断 ","date":"2024-06-12","objectID":"/posts/soc%E6%A1%88%E4%BE%8B/:0:0","tags":null,"title":"内核编译2","uri":"/posts/soc%E6%A1%88%E4%BE%8B/"},{"categories":null,"content":"Entry的不同类型 /* * The bottom two bits of the entry determine how the XArray interprets * the contents: * * 00: Pointer entry * 10: Internal entry * x1: Value entry or tagged pointer * * Attempting to store internal entries in the XArray is a bug. * * Most internal entries are pointers to the next node in the tree. * The following internal entries have a special meaning: * * 0-62: Sibling entries * 256: Retry entry * 257: Zero entry * * Errors are also represented as internal entries, but use the negative * space (-4094 to -2). They're never stored in the slots array; only * returned by the normal API. */ ","date":"2023-08-20","objectID":"/posts/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE-xarray/:1:0","tags":null,"title":"内核基础设施之XArray","uri":"/posts/%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE-xarray/"},{"categories":null,"content":"IRQ Domain 关于IRQ Domain的介绍: linux-6.1.23\\Documentation\\core-api\\irq\\irq-domain.rst IRQ 关联一个irq Domain, ","date":"2023-08-15","objectID":"/posts/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/:1:0","tags":null,"title":"Linux 中断子系统","uri":"/posts/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"IRQ Chip ","date":"2023-08-15","objectID":"/posts/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/:2:0","tags":null,"title":"Linux 中断子系统","uri":"/posts/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"代码走读 GIC 初始化 static int gic_init_bases(struct gic_chip_data *gic, struct fwnode_handle *handle) { int gic_irqs, ret; // 针对不支持BANKED寄存器的特殊处理 if (IS_ENABLED(CONFIG_GIC_NON_BANKED) \u0026\u0026 gic-\u003epercpu_offset) { /* Frankein-GIC without banked registers... */ unsigned int cpu; gic-\u003edist_base.percpu_base = alloc_percpu(void __iomem *); gic-\u003ecpu_base.percpu_base = alloc_percpu(void __iomem *); if (WARN_ON(!gic-\u003edist_base.percpu_base || !gic-\u003ecpu_base.percpu_base)) { ret = -ENOMEM; goto error; } for_each_possible_cpu(cpu) { u32 mpidr = cpu_logical_map(cpu); u32 core_id = MPIDR_AFFINITY_LEVEL(mpidr, 0); unsigned long offset = gic-\u003epercpu_offset * core_id; *per_cpu_ptr(gic-\u003edist_base.percpu_base, cpu) = gic-\u003eraw_dist_base + offset; *per_cpu_ptr(gic-\u003ecpu_base.percpu_base, cpu) = gic-\u003eraw_cpu_base + offset; } enable_frankengic(); } else { /* Normal, sane GIC... */ WARN(gic-\u003epercpu_offset, \"GIC_NON_BANKED not enabled, ignoring %08x offset!\", gic-\u003epercpu_offset); gic-\u003edist_base.common_base = gic-\u003eraw_dist_base; gic-\u003ecpu_base.common_base = gic-\u003eraw_cpu_base; } /* * Find out how many interrupts are supported. * The GIC only supports up to 1020 interrupt sources. */ gic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) \u0026 0x1f; gic_irqs = (gic_irqs + 1) * 32; if (gic_irqs \u003e 1020) gic_irqs = 1020; gic-\u003egic_irqs = gic_irqs; if (handle) { /* DT/ACPI */ gic-\u003edomain = irq_domain_create_linear(handle, gic_irqs, \u0026gic_irq_domain_hierarchy_ops, gic); } else { /* Legacy support */ // 已经删除了对第二级GIC的支持(仅限传统板级方式) /* * For primary GICs, skip over SGIs. * No secondary GIC support whatsoever. */ int irq_base; gic_irqs -= 16; /* calculate # of irqs to allocate */ irq_base = irq_alloc_descs(16, 16, gic_irqs, numa_node_id()); if (irq_base \u003c 0) { WARN(1, \"Cannot allocate irq_descs @ IRQ16, assuming pre-allocated\\n\"); irq_base = 16; } gic-\u003edomain = irq_domain_add_legacy(NULL, gic_irqs, irq_base, 16, \u0026gic_irq_domain_ops, gic); } if (WARN_ON(!gic-\u003edomain)) { ret = -ENODEV; goto error; } gic_dist_init(gic); ret = gic_cpu_init(gic); if (ret) goto error; ret = gic_pm_init(gic); if (ret) goto error; return 0; error: if (IS_ENABLED(CONFIG_GIC_NON_BANKED) \u0026\u0026 gic-\u003epercpu_offset) { free_percpu(gic-\u003edist_base.percpu_base); free_percpu(gic-\u003ecpu_base.percpu_base); } return ret; } ","date":"2023-08-15","objectID":"/posts/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/:3:0","tags":null,"title":"Linux 中断子系统","uri":"/posts/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"中断向量表的安装 __primary_swtich ","date":"2023-08-15","objectID":"/posts/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/:4:0","tags":null,"title":"Linux 中断子系统","uri":"/posts/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"参考 1、GICv3_v4_overview.pdf 2、IHI0069H_gic_architecture_specification.pdf ","date":"2023-08-15","objectID":"/posts/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/:5:0","tags":null,"title":"Linux 中断子系统","uri":"/posts/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"年龄 27 (1995~) ","date":"2023-07-29","objectID":"/about/:1:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"教育背景 2014.9 ~ 2018.7 本科 哈尔滨工业大学(威海) 电子信息工程 2018.9 ~ 2020.6 硕士 哈尔滨工业大学(威海) 信息与通信工程 ","date":"2023-07-29","objectID":"/about/:2:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"工作履历 2020.7至今 上海华为技术有限公司 底层软件工程师(SDE)、系统工程师(SE)、资源组Leader(68人)、项目经理(软件-上海地域) ","date":"2023-07-29","objectID":"/about/:3:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"项目经历 ","date":"2023-07-29","objectID":"/about/:4:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"工作方向：负责无线基站中射频芯片的SOC部分预研、商用导入及存量维护 熟悉ARMv8体系结构与编程；负责无线中射频芯片SOC部分验证及商用导入(Bringup)，现网存量千万级模块SOC\\BSP相关问题接口及维护；\r负责Ethernet(MAC)\\MDIO(PHY)\\ESPI\\LocalBus\\UART\\I2C\\SPI\\WDT\\FLASH\\GIC\\UIO\\EFUSE等IP模块的KMD\\UMD驱动模块开发、调试及存量维护;\r熟悉GIC驱动; 熟悉 SPI-NOR\\MTD 子系统;\r熟悉使用UIO MAP实现用户态驱动; 熟悉TUN\\TAP网络虚拟化;\r熟悉Linux内核编译、裁剪, 熟悉根文件系统制作;\r熟悉GDB、JTAG等工具的使用；熟悉ELF格式、具备二进制分析以及良好的异常问题定位及稳定性问题解决能力；\r负责基站自研虚拟机(PEK)的适配、验证以及商用导入, 了解虚拟化相关原理；\r熟悉QEMU仿真平台，能够基于QEMU平台完成芯片级、板级仿真，加速芯片验证及导入；\r熟悉ARM v8异常模型以及TrustZone机制；熟悉基站平台安全启动的端到端解决方案，作为SE负责射频单元单CPU安全启动相关，动态度量、同构多CPU形态的安全启动等安全可信类方案设计；\r","date":"2023-07-29","objectID":"/about/:4:1","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"工作方向：负责基站射频单元的通用维测子系统开发与维护 负责基于DOPRA中间件的应用层软件开发，熟悉Linux多线程及并发编程; 负责维护、开发、重构射频单元维测、日志、异常监控子系统等应用层软件特性; ","date":"2023-07-29","objectID":"/about/:4:2","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"工作方向：负责基站射频单元MCU相关方案设计及软件开发 熟悉Cortex-M3\\M4架构， 基于Cortex-M4架构芯片的5G分布式居民区解决方案(DRS：Distributed Residential Solution)拉远端BOOTLOADER固件设计与开发;\r熟悉Cortex-M23\\M33架构，基于Cortex-M23架构芯片的射频单元休眠监控子系统固件的设计及开发;\r","date":"2023-07-29","objectID":"/about/:4:3","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"工作方向：负责SD6xxx中频芯片NTN子系统(基于RISC-V架构)的验证 负责基于RISC-V核的NTN子系统固件开发及硅前验证，从0到1搭建编译开发环境，与海思同事交流，熟悉子系统架构、TMR三模冗余RISC-V核以及GIC、I2CC、WDT、UART、TIMER等外设的开发及用例；\r负责主机侧实现通过I2C\\ESPI通路将固件加载到VGMEM；负责基于NTN子系统与APSYS系统的交互；\r","date":"2023-07-29","objectID":"/about/:4:4","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"软技能 工作积极主动； 工作负责，踏实细致，较好的团队协作精神和较强的质量责任意识； 具有较好的承压能力，能够承担具有挑战性的任务； 优秀的逻辑思维，快速的学习能力，思路清晰；善于沟通； 精通 C\\C++，熟悉(内联)ASM、熟悉 Python\\Linux\\Shell 脚本\\Rust, 熟悉 Git\\CMake\\MakeFile 等； 工作负责，踏实细致，拥有较好的团队协作精神和较强的质量责任意识；具有较好的承压能力，能够承担具有挑战性的任务； 具备优秀的逻辑思维，快速学习能力，思路清晰。 ","date":"2023-07-29","objectID":"/about/:5:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"工作内容 202007~202109 RRU业务维测特性Owner, 熟悉维测相关机制实现; 202109~至今 启动与业务初始化SE, 熟悉从上电至业务启动全流程方案; 熟悉安全启动全流程设计; 负责内核驱动编写与维护; 独立完成基于Arm Cortex-M4的BootLoader方案设计及代码实现; ","date":"2023-07-29","objectID":"/about/:6:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"语言 精通C语言; 熟练使用C11, 了解C14\\17\\20; 熟练使用Python语言; 熟练使用Shell脚本编程; 熟练使用Lua、Rust、Go语言; 面试记录 ","date":"2023-07-29","objectID":"/about/:7:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"龙旗 ","date":"2023-07-29","objectID":"/about/:8:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"一面 时间: 2024/5/27 19:30-20:15 面试内容: 比较年轻面试官，没有让自我介绍，问了下在华为的职级、绩效、离职原因; 先问了熟悉不熟悉安卓\\终端、Wifi相关的，直接回答没做过Wifi\\ISP，不太熟悉； 公司会做一些小米平板、华为手表的代工；招人来做鸿蒙的驱动移植，提前布局鸿蒙生态; 然后我给他讲了下当前我们也在做鸿蒙V2X的移植; 加班情况：部门是2111，类似于华为的2012，主要是做技术项目的，下班时间不是很晚，部门是刚成立的，他转过来也不是很久； 没有面试满45min，简历上面的东西基本没咋问，就说了句，都是老华为了，我相信你的技术哈哈; ","date":"2023-07-29","objectID":"/about/:8:1","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"智元机器人 一面： 时间: 2024/5/27 19:30-20:15 面试结果: 通过 面试官看起来是从外面往回走 二面(CEO面) 时间: 2024/5/27 22:00- 薪酬 45*16K ","date":"2023-07-29","objectID":"/about/:9:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"联影微电子 ","date":"2023-07-29","objectID":"/about/:10:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"蓝芯 ","date":"2023-07-29","objectID":"/about/:11:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"简历不匹配 ","date":"2023-07-29","objectID":"/about/:11:1","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"紫荆芯界 ","date":"2023-07-29","objectID":"/about/:12:0","tags":null,"title":"WHO AM I","uri":"/about/"},{"categories":null,"content":"安装 ","date":"2023-07-14","objectID":"/posts/libarchive/:0:0","tags":null,"title":"使用libarchive","uri":"/posts/libarchive/"},{"categories":null,"content":"msys2 (WIN + MinGW) pacman -S libarchive ","date":"2023-07-14","objectID":"/posts/libarchive/:1:0","tags":null,"title":"使用libarchive","uri":"/posts/libarchive/"},{"categories":null,"content":"源码编译 TODO ","date":"2023-07-14","objectID":"/posts/libarchive/:2:0","tags":null,"title":"使用libarchive","uri":"/posts/libarchive/"},{"categories":null,"content":"MCU裸机开发常用的系统架构: 1、轮训模式 对外部事件进行轮训 2、前后台模式 中断处理外部时间，后台循环处理其他事务 3、定时器模式 采用定时器来管理 时间基准： 框架调用用户注册的回调获取 TICK 用户(中断)周期性回调框架接口增加TICK计数 MultiTimer https://github.com/0x1abin/MultiTimer 4、分级状态机、状态机 顶层状态机判断系统忙闲状态 做节能处理； ","date":"2023-06-11","objectID":"/posts/25.-mcu%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/:0:0","tags":null,"title":"MCU裸机编程的代码架构","uri":"/posts/25.-mcu%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"__uio_register_device ","date":"2023-06-11","objectID":"/posts/26.-uio_map/:0:0","tags":null,"title":"UIO 用户态驱动","uri":"/posts/26.-uio_map/"},{"categories":null,"content":"操作 插入1个数 求集合中的最小值 删除最小值 删除任意值(STL 无法直接实现) 修改任意值(STL 无法直接实现) ","date":"2023-04-16","objectID":"/algo/%E5%A0%86/:1:0","tags":null,"title":"堆","uri":"/algo/%E5%A0%86/"},{"categories":null,"content":"存储方式 数组存储, 下标从1开始; 父节点为 x 则，左儿子为 2x, 右儿子为 2x+1： ","date":"2023-04-16","objectID":"/algo/%E5%A0%86/:2:0","tags":null,"title":"堆","uri":"/algo/%E5%A0%86/"},{"categories":null,"content":"接口 up : 节点上移动 down : 节点下移 ","date":"2023-04-16","objectID":"/algo/%E5%A0%86/:3:0","tags":null,"title":"堆","uri":"/algo/%E5%A0%86/"},{"categories":null,"content":"插入 插入值 := 末尾位置插入 , size++, 然后 up 删除 最小值(小根堆) := 删除末位置，size-1, 然后从根down 删除k 位置值 := heap[k] = heap[size]; size–; down(); up() –\u003e down\\up 只会执行一次 修改k 位置值 := heap[k] = x; down(); up() –\u003e down\\up 只会执行一次 ","date":"2023-04-16","objectID":"/algo/%E5%A0%86/:4:0","tags":null,"title":"堆","uri":"/algo/%E5%A0%86/"},{"categories":null,"content":"特征 堆是完全二叉树(除最后一层其他层满，最后一层从左往右排列) ","date":"2023-04-16","objectID":"/algo/%E5%A0%86/:5:0","tags":null,"title":"堆","uri":"/algo/%E5%A0%86/"},{"categories":null,"content":"建立堆 ","date":"2023-04-16","objectID":"/algo/%E5%A0%86/:6:0","tags":null,"title":"堆","uri":"/algo/%E5%A0%86/"},{"categories":null,"content":"正常方式 逐个插入建堆, 时间复杂度O(n*log n) ","date":"2023-04-16","objectID":"/algo/%E5%A0%86/:6:1","tags":null,"title":"堆","uri":"/algo/%E5%A0%86/"},{"categories":null,"content":"快速方式 读入 从 n/2 -\u003e 1 处 开始执行down操作, 时间复杂度 O(n) 证明: 递推 ","date":"2023-04-16","objectID":"/algo/%E5%A0%86/:6:2","tags":null,"title":"堆","uri":"/algo/%E5%A0%86/"},{"categories":null,"content":"基本题 模拟堆 ","date":"2023-04-16","objectID":"/algo/%E5%A0%86/:7:0","tags":null,"title":"堆","uri":"/algo/%E5%A0%86/"},{"categories":null,"content":"练习题 ","date":"2023-04-16","objectID":"/algo/%E5%A0%86/:8:0","tags":null,"title":"堆","uri":"/algo/%E5%A0%86/"},{"categories":null,"content":"字典树？ acwing 算法基础课 #include \u003ciostream\u003e #include \u003cstdio.h\u003e using namespace std; const int N = 100010; // 子节点编号(索引) int son[N][26]; int cnt[N]; // 当前使用节点的索引 // 索引为0的点既是根节点 也是空节点 int idx; int insert(const char* s) { int p = 0; for (int i = 0; s[i]; i++) { int u = s[i] - 'a'; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; } cnt[p] ++; } int query(const char *s) { int p = 0; for (int i = 0; s[i]; i++) { int u = s[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } char str[N]; int main () { int n = 0; char op; scanf(\"%d\\n\", \u0026n); while(n--) { scanf(\"%c %s\\n\", \u0026op, \u0026str[0]); if (op == 'I') insert(str); else printf(\"%d\\n\", query(str)); } } const int N = 100010; // 子节点编号(索引) int son[N][32]; int cnt[N]; // 当前使用节点的索引 // 索引为0的点既是根节点 也是空节点 int idx; ","date":"2023-04-15","objectID":"/algo/trie/:0:0","tags":null,"title":"Trie","uri":"/algo/trie/"},{"categories":null,"content":"练习 AcWing 143. 最大异或对—Trie详解 《算法竞赛进阶指南》, 模板题 WHY: 为什么从高位往低位判断 ANS: 高位为1 数值越大 构造的Trie的每个叶子节点表示一个数, 重点节点表示有该位为0、1的树 将内层循环的遍历N个数, 复杂度 O(n) -\u003e 优化为 -\u003e 遍历至多31层的Trie, 复杂度O(1) ","date":"2023-04-15","objectID":"/algo/trie/:1:0","tags":null,"title":"Trie","uri":"/algo/trie/"},{"categories":null,"content":"主要操作 合并两个集合 查询 两个元素是否在同一个集合 ","date":"2023-04-15","objectID":"/algo/%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:0","tags":null,"title":"并查集","uri":"/algo/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":null,"content":"并查集优化(路径压缩) WHY: 防止查询父节点时间过长 HOW: 让路径的店直接指向根节点 代码实现: # tips: find的同时实现路径压缩 int find(int x) { // 压缩路径 if (p[x] != x) p[x] = find(p[x]); // 此时父节点就是新的父节点 return p[x]; } 按秩优化(无用) 让矮的树接到高的树 ","date":"2023-04-15","objectID":"/algo/%E5%B9%B6%E6%9F%A5%E9%9B%86/:2:0","tags":null,"title":"并查集","uri":"/algo/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":null,"content":"基本模板题 合并集合 连通块中点的数量 ","date":"2023-04-15","objectID":"/algo/%E5%B9%B6%E6%9F%A5%E9%9B%86/:3:0","tags":null,"title":"并查集","uri":"/algo/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":null,"content":"练习题 食物链 WHY: 为什么 find的时候 需要 d[x] = d[p[x]] ANS: 因为dx 是与父节点之间的距离，合并两棵树时，dx 并一定为 1, 因此后续压缩路径的时候dx并不一定为1 ","date":"2023-04-15","objectID":"/algo/%E5%B9%B6%E6%9F%A5%E9%9B%86/:4:0","tags":null,"title":"并查集","uri":"/algo/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":null,"content":"acwing 基础课 第一章 基础算法(一) ","date":"2023-04-15","objectID":"/algo/%E6%8E%92%E5%BA%8F/:1:0","tags":null,"title":"并查集","uri":"/algo/%E6%8E%92%E5%BA%8F/"},{"categories":null,"content":"快排 void quick_sort(int *q, int l, int r) { // 边界处理, 记住其中一种即可 // 取端点可能会退化为O(n) // 左端点要用 (l,j), (j+1,r) // int x = q[l]; // 右端点要用 (l,i-1), (i,r) // int x = q[r]; // int x = q[(l+r+1) \u003e\u003e 1]; int x = q[rand() % (r - l + 1) + l]; // off-the-end, 后面直接先增加 int i = l - 1; int j = r + 1; if (l \u003e= r) return; while (i \u003c j) { do i++; while (q[i] \u003c x); do j--; while (q[j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j+1, r); } ","date":"2023-04-15","objectID":"/algo/%E6%8E%92%E5%BA%8F/:2:0","tags":null,"title":"并查集","uri":"/algo/%E6%8E%92%E5%BA%8F/"},{"categories":null,"content":"不管读字符还是读字符串都用%s来读取 // 读取 I abc char op[2]; scanf(\"%s%s\", op, str); vector 支持[] size() empty() clear() 清空 front()/back() 数组头尾元素 push_back()/pop_back begin()/end() 首尾元素 支持字典序比较 pair first 第一个元素 second 第二个元素 string size()/length 返回长度 empty() clear() substr(a,b) 得到一个下标位a长度位b的子字符串 substr(a) 得到一个下表为a长度取最长的子字符串 c_str() 取string定义数组的首地址 queue size() empty() push() 在队尾插入一个元素 front()/back() 返回队头/队尾元素 pop() 弹出队头元素 priority_queue 优先队列(堆) 默认大根堆 size() empty() push() top() pop() 定义小根堆: priority_queue\u003cint , vector\u003cint\u003e , greater\u003cint\u003e\u003e stack size() empty() push() pop() top() deque 支持[] size() empty() clear() front()/back() 头尾元素 push_back()/push_front() 在头尾插入 begin()/end() set , map , multimap , multiset , 基于平衡二叉树 (红黑树) 维护一个有序数列 大部分函数时间复杂度都是logn (因为是树) size() empty() clear() begin()/end() 支持++ -- 时间复杂度 O(logn) lower_bound()/upper_bound() lower_bound(x) 返回一个大于等于x的最小值 upper_bound(x) 返回一个大于x的最小值 set / multiset set不支持重复数插入 插入重复数直接跳过 insert() 插入一个数 find() 查找一个数 count() 返回一个数存入的个数 erase() (1) 输入是一个x , 删除全部x , 时间复杂度 O(k + logn) (2) 输入是一个迭代器 , 删除这个迭代器 map / multimap insert() 插入的是一个pair erase() 输入的参数是pair 或者 迭代器 find() 支持[] unordered_set , unordered_map , unordered_multiset , unordered_multimap 基本跟上面一个一样 查找删改时间复杂度是 O(1) 不支持lower_bound()/upper_bound() 迭代器的++ -- bitset 压位 bitset\u003c放大小\u003e s; 初始化时候全为0 —— false; ~取反 \u0026且 |或 ^异或 == , != 移位 \u003c\u003c \u003e\u003e 支持[] count() 返回有多少个1 any() 判断是否有1 none() 判断是否全为0 set() 把所有位置为1 set(k,v) 将第k位变成v reset() 把所有位置为0 flip() 等价于~ flip(x) 第k位取反 作者：yxc_助手1387号 链接：https://www.acwing.com/solution/content/90205/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2023-04-15","objectID":"/algo/stl/:0:0","tags":null,"title":"算法STL","uri":"/algo/stl/"},{"categories":null,"content":" #include \u003ciostream\u003e #include \u003cfunctional\u003e int myprint() { std::cout \u003c\u003c __func__ \u003c\u003c std::endl; return 1; } namespace Mico { template\u003ctypename RetType, typename... Args\u003e class Functional {}; template\u003ctypename RetType, typename... Args\u003e class Functional\u003cRetType(Args...)\u003e { using FuncPtrType = RetType (*)(Args...); public: Functional(FuncPtrType func) : _func(func) { } RetType operator()(Args... args) { std::cout \u003c\u003c __func__ \u003c\u003c std::endl; return _func(args...); } private: FuncPtrType _func; }; } int main () { Mico::Functional\u003cint()\u003e fp{myprint}; fp(); } 上面的代码没有做到类型擦除？实际上只是相当于函数指针？ template\u003ctypename RetType, typename... Args\u003e class Functional {}; // 偏特化 template\u003ctypename RetType, typename... Args\u003e class Functional\u003cRetType(Args...)\u003e { using FuncPtrType = RetType (*)(Args...); class ICallable { public: virtual ~ICallable() = default; virtual RetType Invoke(Args...) = 0; }; template \u003ctypename T\u003e class CallableT : public ICallable { public: CallableT(const T\u0026 t) : t_(t) { } ~CallableT() override = default; RetType Invoke(Args... args) override { return t_(args...); } private: T t_; }; public: template \u003ctypename T\u003e Functional\u0026 operator=(T t) { callable_ = std::make_unique\u003cCallableT\u003cT\u003e\u003e(t); return *this; } RetType operator()(Args... args) { std::cout \u003c\u003c __func__ \u003c\u003c std::endl; return callable_-\u003eInvoke(args...); } private: std::unique_ptr\u003cICallable\u003e callable_; }; ","date":"2023-04-11","objectID":"/posts/24.-%E5%AE%9E%E7%8E%B0std_function/:0:0","tags":null,"title":"实现std::function","uri":"/posts/24.-%E5%AE%9E%E7%8E%B0std_function/"},{"categories":null,"content":"console := termial := tty ptmx、pts ","date":"2023-02-26","objectID":"/posts/22.-console/:0:0","tags":null,"title":"consle/tty/ptmx/pts","uri":"/posts/22.-console/"},{"categories":null,"content":" 下载Ubuntu镜像 安装Virtual Box 下载内核源码, linux-source 这个包可能和当前的内核版本不匹配？, 所以使用linux-source-5.xx.x包 sudo apt-get install linux-headers-$(uname -r) sudo apt-get install linux-source-5.xx.x cd /usr/src/linux-source-5.19.0 sudo tar jxf /usr/src/linux-source-5.19.0.tar.bz2 ","date":"2023-02-26","objectID":"/posts/21.-linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/:0:0","tags":null,"title":"内核编译","uri":"/posts/21.-linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"},{"categories":null,"content":"依赖安装 sudo apt install build-essential libncurses5-dev libssl-dev flex bison ","date":"2023-02-26","objectID":"/posts/21.-linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/:1:0","tags":null,"title":"内核编译","uri":"/posts/21.-linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"},{"categories":null,"content":"编译内核 #清除之前编译环境 make mrproper # 编译 sudo make defconfig sudo make -j4 ","date":"2023-02-26","objectID":"/posts/21.-linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/:2:0","tags":null,"title":"内核编译","uri":"/posts/21.-linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"},{"categories":null,"content":" 安装基本软件 sudo apt install zsh git curl vim ","date":"2023-02-26","objectID":"/posts/21.-linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/:3:0","tags":null,"title":"内核编译","uri":"/posts/21.-linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"},{"categories":null,"content":"串口输出乱码 时钟配置不正确 Cortex-M0 与 Cortex-M23 Cortex-M3 与 Cortex-M33 ","date":"2023-02-09","objectID":"/posts/19.-mcu-%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91/:1:0","tags":null,"title":"MCU开发踩坑","uri":"/posts/19.-mcu-%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91/"},{"categories":null,"content":"如何死锁? ABBA 同线程多次调用不可重入锁 ","date":"2023-02-09","objectID":"/posts/20.-locking/:1:0","tags":null,"title":"锁","uri":"/posts/20.-locking/"},{"categories":null,"content":"可重入与不可重入 ","date":"2023-02-09","objectID":"/posts/20.-locking/:2:0","tags":null,"title":"锁","uri":"/posts/20.-locking/"},{"categories":null,"content":"用户态与内核态 ","date":"2023-02-09","objectID":"/posts/20.-locking/:3:0","tags":null,"title":"锁","uri":"/posts/20.-locking/"},{"categories":null,"content":"库函数与锁 ","date":"2023-02-09","objectID":"/posts/20.-locking/:4:0","tags":null,"title":"锁","uri":"/posts/20.-locking/"},{"categories":null,"content":"死锁 ","date":"2023-02-09","objectID":"/posts/20.-locking/:5:0","tags":null,"title":"锁","uri":"/posts/20.-locking/"},{"categories":null,"content":"形成死锁的必要条件 互斥条件 不可剥夺条件 请求与保持条件 循环等待条件 ","date":"2023-02-09","objectID":"/posts/20.-locking/:5:1","tags":null,"title":"锁","uri":"/posts/20.-locking/"},{"categories":null,"content":"如何避免死锁 破坏上述的必要条件 互斥条件 :: 无法破坏, 锁的目的就是互斥 不可剥夺条件 :: 无法获取锁时, 直接失败或者等待超时 请求与保持条件 :: 在加锁前，增加资源池判断资源是否已经在池内 循环等待条件 :: 保证加锁的顺序 ","date":"2023-02-09","objectID":"/posts/20.-locking/:6:0","tags":null,"title":"锁","uri":"/posts/20.-locking/"},{"categories":null,"content":"参考 深入理解高并发原理 ","date":"2023-02-09","objectID":"/posts/20.-locking/:7:0","tags":null,"title":"锁","uri":"/posts/20.-locking/"},{"categories":null,"content":"占用资源少 实时性方面？ 实时性的定义 在有限截止时间内任务得到调度 ","date":"2023-02-05","objectID":"/posts/18.-rtos%E4%B8%8Elinux/:0:0","tags":null,"title":"RTOS与LINUX差异","uri":"/posts/18.-rtos%E4%B8%8Elinux/"},{"categories":null,"content":"ARM 官方文档: https://tf-m-user-guide.trustedfirmware.org/introduction/readme.html Armv8-M and Armv8.1-M architectures. cortex-m23 cortex-m33 cortex-m55 cortex-m85 或者其他物理核隔离的系统, 比如Cypress PSoC® 64 Secure Microcontrollers; PSA Certified guidelines SPE \u003c–\u003e NSPE mcuboot https://docs.mcuboot.com/design.html 阅读TF-M的官方文档是发现BL2使用是mcuboot这个项目。 mcuboot被设计为一个函数库，官方文档给出的其中一个原因是函数库可以进行单元测试，但是完整的应用不能够(A library can be unit tested, but an application can’t.)。因此，mcuboot并不包含实际跳转到APP执行的代码。 ","date":"2022-12-09","objectID":"/posts/17.-tf-m/:0:0","tags":null,"title":"TF-M","uri":"/posts/17.-tf-m/"},{"categories":null,"content":" 哪里买 品牌 价格 酒精度 麦芽度 评价 盒马 盒马 德式小麦白 精酿原浆 15.9元 / 1000ml 4.5%vol 12.1P 泡沫绵密消散慢浑浊好喝 盒马 盒马 黄油风味皮尔森啤酒 19.9元 / 650ml 2.5%vol 8P 好喝 随便 青岛白啤 元 / ml 4.1%vol 11P 好喝 随便 雪花 醇香啤酒(易拉罐) 4.88元 / 500ml 4.7%vol 12P 泡沫丰富消散适中, 酒体澄澈, 不错 盒马 盒马 印度淡色艾尔 精酿原浆 23.9元 / 1000ml 6.1%vol 14.2P 泡沫绵密消散慢, 略苦, 劲蛮大 盒马 盒马精酿原浆 桂圆红枣小麦啤酒(冬限定) 18.9元 / 460ml 2.8%vol 12P 酸, 口感忘了 盒马 芒果海盐古斯酸啤酒 19.9元 / 650ml 2.8%vol 8P 芒果味不多, 酸, 色浅浑浊 随便 青岛百年国潮 7.83元 / 500ml 4.1%vol NA 清爽 盒马 乌苏 赤焱 4.5元 / 500ml 5.8%vol 13.5P 凑合, 口感一般 盒马 燕京U8 4.9元 / 500ml 2.5%vol 8P 非常一般般 盒马 百威 黑金啤酒 9.5元 / 600ml 5.1%vol 11.8P Na 盒马 弗林伯格 小麦啤酒 9.9元 / 330ml 5.5%vol 13.4P 一般 盒马 赤耳 烟云龙井啤酒 12.8元 / 330ml 5.5%vol 13.4P 第一口龙井,蛮奇怪的味道 啤酒杯: 39.9元 鹅岛啤酒杯(797啤酒杯) 啤酒, 个人喜好不同，不会喝，喜欢喝的基本都是白啤那种感觉 ","date":"2022-12-09","objectID":"/life/51.-%E5%95%A4%E9%85%92/:0:0","tags":null,"title":"啤酒!","uri":"/life/51.-%E5%95%A4%E9%85%92/"},{"categories":["Linux"],"content":"title: \"\" date: 2022-11-29T01:01:47+08:00 draft: false 与中断例程之间的同步：禁止中断 UP 不需要同步 SMP 才需要 ","date":"2022-11-29","objectID":"/posts/df58b61/:1:0","tags":["draft","同步原语"],"title":"Linux 内核同步原语","uri":"/posts/df58b61/"},{"categories":["Linux"],"content":"内核锁 ","date":"2022-11-29","objectID":"/posts/df58b61/:2:0","tags":["draft","同步原语"],"title":"Linux 内核同步原语","uri":"/posts/df58b61/"},{"categories":["Linux"],"content":"用户态锁 ","date":"2022-11-29","objectID":"/posts/df58b61/:3:0","tags":["draft","同步原语"],"title":"Linux 内核同步原语","uri":"/posts/df58b61/"},{"categories":["Linux"],"content":"参考 kernel_locking ","date":"2022-11-29","objectID":"/posts/df58b61/:4:0","tags":["draft","同步原语"],"title":"Linux 内核同步原语","uri":"/posts/df58b61/"},{"categories":null,"content":"Lua 缩写 luaX == Lua lex LuaZ == LuaS == ","date":"2022-11-20","objectID":"/posts/12.-lua/:1:0","tags":null,"title":"Lua","uri":"/posts/12.-lua/"},{"categories":null,"content":"时钟延展 ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:2:0","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"总线挂死 ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:3:0","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"I2C子系统 Linux内核实现 TODO ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:4:0","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"软件模拟I2C Master(GPIO模拟) ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:5:0","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"检测总线是否空闲 ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:5:1","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"发送START // 确保总线空闲 // HOW TO us_delay(4); // 额外的 SDA=1;SCL=1; // 是否需要延时？延时多少 // START 符号 SDA=0;SCL=1; // T_hd;sta \u003e 4.0 us us_delay(4); SDA=0;SCL=0; ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:5:2","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"发送 // T_low \u003e 4.7, T_high \u003e 4.0us SCL = 0; us_delay(5); // 数据 SDA = xx; // T_su;dat \u003e 250ns us_delay(1); // 拉高SCL SCL = 1; // T_high \u003e 4.0us us_delay(4); // 拉低SCL SCL = 0; // T_high \u003e 4.0us us_delay(1); ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:6:0","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"停止 SDA=0;SCL=0; us_delay(5); SCL=1; // T_su;sto \u003e 4.0us us_delay(4); SDA=0; // T_hd;dat us_delay(5); ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:7:0","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"GPIO 模式配置(ST/GD) 输入 浮空输入 输出 开漏输出模式 NOPULL 模式 FREQ HIGH模式 GD32、STM32在GPIO 输出配置章节有如下描述; 开漏模式：输出控制寄存器设置为“0”时，相应引脚输出低电平；输出控制寄存器设置 为 “1”，相应管脚处于高阻状态； ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:8:0","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"为什么不能直接使用芯片内部的上拉电阻 内部实现的是弱上拉(40K Ohm), 不满足时序要求； 外部上拉电阻一般使用4.7K Ohm; ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:8:1","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"I2C Slave ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:9:0","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"TI 参考代码 fr2111_swi2c_master.h /* --COPYRIGHT--,BSD * Copyright (c) 2016, Texas Instruments Incorporated * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * * Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * * Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * * Neither the name of Texas Instruments Incorporated nor the names of * its contributors may be used to endorse or promote products derived * from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * --/COPYRIGHT--*/ //***************************************************************************** #include \u003cmsp430.h\u003e #include \u003cstdbool.h\u003e #include \u003cstdint.h\u003e /* Pin Definitions. These should be changed depending on the device that * you are using. */ #define SWI2C_SCL BIT3 #define SWI2C_SDA BIT2 #define SWI2C_PxDIR P1DIR #define SWI2C_PxOUT P1OUT #define SWI2C_PxIN P1IN #define SWI2C_SDA_LOW SWI2C_PxDIR |= SWI2C_SDA #define SWI2C_SCL_LOW SWI2C_PxDIR |= SWI2C_SCL #define SWI2C_SCL_HIGH SWI2C_PxDIR \u0026= ~SWI2C_SCL #define SWI2C_SDA_HIGH SWI2C_PxDIR \u0026= ~SWI2C_SDA /* Defines the buffer size to be used. This will change depending on your * application and the size requirements for the transfer. */ /* Configuration structure for performing an I2C transaction */ typedef struct _SWI2C_I2CTransaction { uint8_t address; uint_fast16_t numWriteBytes; uint8_t* writeBuffer; uint_fast16_t numReadBytes; uint8_t* readBuffer; bool repeatedStart; } SWI2C_I2CTransaction; /* Timer period for determining the clock rate of the I2C data clock. Note that * the timer is sourced from SMCLK and that this number is equal to the duration * of roughly HALF a clock period. For example, if SMCLK is set to 3MHz and the * period below is set to 15, we would end up with an I2C data rate of * approximately 100Khz. * * In short, the I2C data rate frequency can be calculated by: * * I2C Data Rate = SMCLK Frequency * ___________________ * * 2 * TimerPeriod */ #define SWI2C_TIMER_PERIOD 15 /* Macro for a timer iteration */ #define TIMER_ITERATION() TB0CCTL0 \u0026= ~(CCIFG); \\ while(!(TB0CCTL0 \u0026 CCIFG)); /* Function Prototypes */ //***************************************************************************** // //! Initializes the software I2C master. This function takes the port //! definitions that are given above and configures the device for software //! I2C operation. //! //! \\return None // //***************************************************************************** extern void SWI2C_initI2C(void); //***************************************************************************** // //! Starts an I2C transaction over the configured I2C master device. Note that //! this function is blocking until the transaction is completed. If a timeout //! feature is required, the user should use the watchdog module of their MCU //! in tandem with this function. Since the I2C slave has the ability to ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:9:1","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"Linux I2C 驱动 ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:10:0","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"GPIO 模拟 算法: linux-6.1-rc2\\drivers\\i2c\\algos\\i2c-algo-bit.c 总线: linux-6.1-rc2\\drivers\\i2c\\busses\\i2c-gpio.c ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:10:1","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"学习文档 UM10204(I2C-bus specification and user manual) Texas Instruments SPRABJ6(Software Implementation of PMBus Over I2C for TMS320F2803x) 从机状态机: SLAA703A(Software I2C on MSP430™ MCUs) ","date":"2022-10-19","objectID":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/:11:0","tags":null,"title":"I2C总线","uri":"/posts/11.-i2c%E6%80%BB%E7%BA%BF/"},{"categories":null,"content":"SPI 同步通信协议 如何实现一主多从？ 通过多个片选，每个片选对应一个从机 MOSI MISO ","date":"2022-10-19","objectID":"/posts/10.-%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/:0:1","tags":null,"title":"SPI总线","uri":"/posts/10.-%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"I2C 同步通信协议 如何实现一主多从？ 通过使用多个从机地址 开漏结构 \u003c-\u003e 数据双向传输 SCL SDA 典型速率: 100Kbps, 400Kbpx, 3.4Mbps ","date":"2022-10-19","objectID":"/posts/10.-%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/:0:2","tags":null,"title":"SPI总线","uri":"/posts/10.-%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"UART 异步通信协议 慢 115200 ","date":"2022-10-19","objectID":"/posts/10.-%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/:0:3","tags":null,"title":"SPI总线","uri":"/posts/10.-%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"原料 秋梨 银耳 百合 橘皮 葛根 话梅 枸杞 黄冰糖 ","date":"2022-10-12","objectID":"/life/50.-%E5%B0%8F%E5%90%8A%E6%A2%A8%E6%B1%A4/:1:0","tags":null,"title":"小吊梨汤","uri":"/life/50.-%E5%B0%8F%E5%90%8A%E6%A2%A8%E6%B1%A4/"},{"categories":null,"content":"遗留问题: 从spi-nor目录的Makefile可以看出目录下文件的关系, 可以看出spi-nor子系统主要由核心、控制器以及FLASH厂商组成； # SPDX-License-Identifier: GPL-2.0 spi-nor-objs := core.o sfdp.o swp.o otp.o sysfs.o spi-nor-objs += atmel.o spi-nor-objs += catalyst.o spi-nor-objs += eon.o spi-nor-objs += esmt.o spi-nor-objs += everspin.o spi-nor-objs += fujitsu.o spi-nor-objs += gigadevice.o spi-nor-objs += intel.o spi-nor-objs += issi.o spi-nor-objs += macronix.o spi-nor-objs += micron-st.o spi-nor-objs += spansion.o spi-nor-objs += sst.o spi-nor-objs += winbond.o spi-nor-objs += xilinx.o spi-nor-objs += xmc.o obj-$(CONFIG_MTD_SPI_NOR) += spi-nor.o obj-$(CONFIG_MTD_SPI_NOR) += controllers/ – drivers\\mtd\\spi-nor\\controllers\\intel-spi.c https://lwn.net/Articles/692383/ – drivers\\mtd\\spi-nor\\controllers\\hisi-sfc.c 对应的Hi3519芯片, 该芯片的设备树并没有开源，需要对应的SDK开发包才能看到。 初始化顺序 FILE :: include\\linux\\init.h /* * Early initcalls run before initializing SMP. * * Only for built-in code, not modules. */ #define early_initcall(fn) __define_initcall(fn, early) /* * A \"pure\" initcall has no dependencies on anything else, and purely * initializes variables that couldn't be statically initialized. * * This only exists for built-in code, not for modules. * Keep main.c:initcall_level_names[] in sync. */ #define pure_initcall(fn) __define_initcall(fn, 0) #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4) #define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s) #define __initcall(fn) device_initcall(fn) ","date":"2022-10-06","objectID":"/posts/7.spi_nor/:1:0","tags":null,"title":"MTD子系统与JFFS2文件系统","uri":"/posts/7.spi_nor/"},{"categories":null,"content":"VSCode :: 编辑器即IDE Tabby :: 终端工具 MobaXTerm :: 远程工具 oh-my-zsh :: opengrok :: 代码浏览器,用于阅读源码 BandZip :: 压缩 Beyond Compare :: 比较工具 cloc :: 统计代码行数 ","date":"2022-07-18","objectID":"/posts/3.-coder_tools/:0:0","tags":null,"title":"习惯迁移","uri":"/posts/3.-coder_tools/"},{"categories":["工具"],"content":"[TOC] 阅读大型源码项目除传统的Souce Insight、Scitools Understand等付费PC端工具，基于Web的 {OpenGrok 和 Elixir Cross Reference 也是相当惊艳，方便躺在床上用ipad阅读源代码。作为开源工具，不仅免费而且支持用户自己搭建。如下为{OpenGrok的界面: 另外，二者都提供许多常见的大型项目(https://github.com/oracle/opengrok/wiki/Installations 以及https://elixir.bootlin.com/)，足够使用并且免除动手搭建的麻烦。但毕竟是国外网站，偶尔访问速度上不去，故自己动手搭建一套还是非常有用的。OpenGrok的源码方式安装还是蛮麻烦的，所以使用官方的Docker镜像并且自己写了个小脚本方便进行管理。 ","date":"0001-01-01","objectID":"/posts/76052be/:0:0","tags":["opengrok","tools"],"title":"{OpenGrok引擎浏览开源代码","uri":"/posts/76052be/"},{"categories":["工具"],"content":"1. Debian/Ubuntu系统搭建{OpenGrok 博主使用的是Debian系统，所以包管理器为apt，如果你使用其它系统或者想要改变端口或者源码目录，简单修改脚本即可。 (1). 安装 Docker / Opengrok ./opengrok.sh install 该命令做了如下工作: 删除已存在的Docker、启用https、加入docker的官方gpg密钥、校验密钥、添加稳定源、安装Docker社区版、安装opengrok/docker image、创建opengrok目录。 sudo apt remove docker docker-engine docker.io containerd runc curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - sudo apt-key fingerprint 0EBFCD88 sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/debian \\ $(lsb_release -cs) \\ stable\" sudo apt update sudo apt-get install -y docker-ce docker-ce-cli containerd.io sudo docker pull opengrok/docker sudo mkdir -p $GROKPATH/etc sudo mkdir -p $GROKPATH/data sudo mkdir -p $GROKPATH/src (2). 运行opengrok ./opengrok.sh run 该命令执行以下工作：停止正在的运行的opengrok/docker进程、删除之前生成的配置和数据(可选)、后台运行opengrok/docker映像。 sudo docker stop $CONTAINER_NAME sudo docker rm $CONTAINER_NAME sudo rm -rf $GROKPATH/etc/* sudo rm -rf $GROKPATH/data/* %模板 sudo docker run -d \\ --name $CONTAINER_NAME \\ -p $PORT:8080/tcp \\ -e REINDEX=$REINDEX \\ -v $GROKPATH/src/:/opengrok/src/ \\ -v $GROKPATH/etc/:/opengrok/etc/ \\ -v $GROKPATH/data/:/opengrok/data/ \\ opengrok/docker:latest sudo docker run -d \\ --name \"opengrok\" \\ -p 8888:8080/tcp \\ -e REINDEX=\"0\" \\ -v ~/opengrok/src/:/opengrok/src/ \\ -v ~/opengrok/etc/:/opengrok/etc/ \\ -v ~/opengrok/data/:/opengrok/data/ \\ opengrok/docker:latest (3). 如果添加了其他项目，运行如下命令重新生成索引 ./opengrok.sh reindex 或 docker exec \u003ccontainer\u003e /scripts/index.sh ","date":"0001-01-01","objectID":"/posts/76052be/:1:0","tags":["opengrok","tools"],"title":"{OpenGrok引擎浏览开源代码","uri":"/posts/76052be/"},{"categories":["工具"],"content":"完整脚本 #!/bin/bash GROKPATH=~/opengrok CONTAINER_NAME=opengrok PORT=8888 REINDEX=\"0\" function pr_info() { echo -e \"\\033[32m\" $1 \"\\033[0m\" } # install docker community edition and pull opengrok official image function install() { sudo apt install -y curl sudo apt remove docker docker-engine docker.io containerd runc curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - sudo apt-key fingerprint 0EBFCD88 sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/debian \\ $(lsb_release -cs) \\ stable\" sudo apt update sudo apt-get install -y docker-ce docker-ce-cli containerd.io sudo docker pull opengrok/docker sudo mkdir -p $GROKPATH/etc sudo mkdir -p $GROKPATH/data sudo mkdir -p $GROKPATH/src pr_info \"\\nDone!\" } function run() { echo \"check exist docker opengrok...\" sudo docker stop $CONTAINER_NAME sudo docker rm $CONTAINER_NAME echo \"delete existing data and etc...\" sudo rm -rf $GROKPATH/etc/* sudo rm -rf $GROKPATH/data/* echo \"run docker image opengrok/docker:latest\" sudo docker run -d \\ --name $CONTAINER_NAME \\ -p $PORT:8080/tcp \\ -e REINDEX=\"60\" \\ -v $GROKPATH/src/:/opengrok/src/ \\ -v $GROKPATH/etc/:/opengrok/etc/ \\ -v $GROKPATH/data/:/opengrok/data/ \\ opengrok/docker:1.5.12 pr_info \"\\n opengrok/docker running.\" } # Reindex When you add some new Project function reindex() { sudo docker exec opengrok /scripts/index.sh \u0026 pr_info \"\\nDone!\" } function usage() { echo -e \"\\033[31m\" \"\\nusage:\" \"\\t./opengropk.sh [install|run|reindex|usage]\" echo -e \"\\tinstall\\t install docker community edition and opengrok official image\" echo -e \"\\trun\\trun opengrok at specific port\" echo -e \"\\treindex\\treindex when you add some new project in \\${GROKPATH}/src directory\" echo -e \"\\033[0m\" } if [ $# -eq 0 ]; then usage fi case $1 in \"install\") install ;; \"run\") run ;; \"reindex\") reindex ;; *) usage ;; esac ","date":"0001-01-01","objectID":"/posts/76052be/:2:0","tags":["opengrok","tools"],"title":"{OpenGrok引擎浏览开源代码","uri":"/posts/76052be/"},{"categories":["工具"],"content":"2. 剧透一下，Windows 也可以搭建哦~ , 适合一些只能在本机看的私有项目 (1) 下载并安装Docker For Windows; (2) 启动 Docker Desktop 守护进程； (3) 在合适的位置创建opengrok文件夹，比如：d:/docker/opengrok/，并创建三个子文件夹etc、data、src； (4) 将源代码解压到opengrok/src文件夹； (5) 运行如下命令运行opengrok映像 docker run -d --name \"opengrok\" -p 8888:8080/tcp -e REINDEX=\"0\" -v d:/docker/opengrok/src/:/opengrok/src/ -v d:/docker/opengrok/etc/:/opengrok/etc/ -v d:/docker/opengrok/data/:/opengrok/data/ opengrok/docker:latest (6) 若后续添加源代码则运行如下命令进行重新索引 docker exec opengrok /scripts/index.sh 注 ：Hyper-V会与VirtualBox冲突 解决方法: (a). 关闭Hyper-V，管理员终端运行如下命令； bcdedit /set hypervisorlaunchtype off (b). 若还是要使用Docker可以尝试使用旧版的Docker ToolBox； (c). 尝试在WSL或者虚拟机里面的Linux安装Docker/OpenGrok。 2022 更新 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f7632745dfe1 opengrok/docker:1.5.12 \"/scripts/start.sh\" 2 months ago Up 2 months 0.0.0.0:8888-\u003e8080/tcp, :::8888-\u003e8080/tcp opengrok 最新版本的opengrok镜像命令字好像与之前并不一样，这里找到与之前命令一样的 1.5.12 版本, 拉取指定版本的opengrok镜像进行使用。 ","date":"0001-01-01","objectID":"/posts/76052be/:3:0","tags":["opengrok","tools"],"title":"{OpenGrok引擎浏览开源代码","uri":"/posts/76052be/"},{"categories":["工具"],"content":"参考 https://github.com/OpenGrok/docker ","date":"0001-01-01","objectID":"/posts/76052be/:4:0","tags":["opengrok","tools"],"title":"{OpenGrok引擎浏览开源代码","uri":"/posts/76052be/"}]