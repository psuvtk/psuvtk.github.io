<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 算法STL | Early is on Time</title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="算法STL" />
<meta property="og:description" content="不管读字符还是读字符串都用%s来读取
// 读取 I abc char op[2]; scanf(&#34;%s%s&#34;, op, str); vector 支持[] size() empty() clear() 清空 front()/back() 数组头尾元素 push_back()/pop_back begin()/end() 首尾元素 支持字典序比较 pair first 第一个元素 second 第二个元素 string size()/length 返回长度 empty() clear() substr(a,b) 得到一个下标位a长度位b的子字符串 substr(a) 得到一个下表为a长度取最长的子字符串 c_str() 取string定义数组的首地址 queue size() empty() push() 在队尾插入一个元素 front()/back() 返回队头/队尾元素 pop() 弹出队头元素 priority_queue 优先队列(堆) 默认大根堆 size() empty() push() top() pop() 定义小根堆: priority_queue&lt;int , vector&lt;int&gt; , greater&lt;int&gt;&gt; stack size() empty() push() pop() top() deque 支持[] size() empty() clear() front()/back() 头尾元素 push_back()/push_front() 在头尾插入 begin()/end() set , map , multimap , multiset , 基于平衡二叉树 (红黑树) 维护一个有序数列 大部分函数时间复杂度都是logn (因为是树) size() empty() clear() begin()/end() 支持&#43;&#43; -- 时间复杂度 O(logn) lower_bound()/upper_bound() lower_bound(x) 返回一个大于等于x的最小值 upper_bound(x) 返回一个大于x的最小值 set / multiset set不支持重复数插入 插入重复数直接跳过 insert() 插入一个数 find() 查找一个数 count() 返回一个数存入的个数 erase() (1) 输入是一个x , 删除全部x , 时间复杂度 O(k &#43; logn) (2) 输入是一个迭代器 , 删除这个迭代器 map / multimap insert() 插入的是一个pair erase() 输入的参数是pair 或者 迭代器 find() 支持[] unordered_set , unordered_map , unordered_multiset , unordered_multimap 基本跟上面一个一样 查找删改时间复杂度是 O(1) 不支持lower_bound()/upper_bound() 迭代器的&#43;&#43; -- bitset 压位 bitset&lt;放大小&gt; s; 初始化时候全为0 —— false; ~取反 &amp;且 |或 ^异或 == , !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://psuvtk.github.io/algo/stl/" /><meta property="article:section" content="algo" />
<meta property="article:published_time" content="2023-04-15T22:15:47&#43;08:00" />
<meta property="article:modified_time" content="2023-04-15T22:15:47&#43;08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="算法STL"/>
<meta name="twitter:description" content="不管读字符还是读字符串都用%s来读取
// 读取 I abc char op[2]; scanf(&#34;%s%s&#34;, op, str); vector 支持[] size() empty() clear() 清空 front()/back() 数组头尾元素 push_back()/pop_back begin()/end() 首尾元素 支持字典序比较 pair first 第一个元素 second 第二个元素 string size()/length 返回长度 empty() clear() substr(a,b) 得到一个下标位a长度位b的子字符串 substr(a) 得到一个下表为a长度取最长的子字符串 c_str() 取string定义数组的首地址 queue size() empty() push() 在队尾插入一个元素 front()/back() 返回队头/队尾元素 pop() 弹出队头元素 priority_queue 优先队列(堆) 默认大根堆 size() empty() push() top() pop() 定义小根堆: priority_queue&lt;int , vector&lt;int&gt; , greater&lt;int&gt;&gt; stack size() empty() push() pop() top() deque 支持[] size() empty() clear() front()/back() 头尾元素 push_back()/push_front() 在头尾插入 begin()/end() set , map , multimap , multiset , 基于平衡二叉树 (红黑树) 维护一个有序数列 大部分函数时间复杂度都是logn (因为是树) size() empty() clear() begin()/end() 支持&#43;&#43; -- 时间复杂度 O(logn) lower_bound()/upper_bound() lower_bound(x) 返回一个大于等于x的最小值 upper_bound(x) 返回一个大于x的最小值 set / multiset set不支持重复数插入 插入重复数直接跳过 insert() 插入一个数 find() 查找一个数 count() 返回一个数存入的个数 erase() (1) 输入是一个x , 删除全部x , 时间复杂度 O(k &#43; logn) (2) 输入是一个迭代器 , 删除这个迭代器 map / multimap insert() 插入的是一个pair erase() 输入的参数是pair 或者 迭代器 find() 支持[] unordered_set , unordered_map , unordered_multiset , unordered_multimap 基本跟上面一个一样 查找删改时间复杂度是 O(1) 不支持lower_bound()/upper_bound() 迭代器的&#43;&#43; -- bitset 压位 bitset&lt;放大小&gt; s; 初始化时候全为0 —— false; ~取反 &amp;且 |或 ^异或 == , !"/>

  
  
    
  
  
  <link rel="stylesheet" href="https://psuvtk.github.io/css/style-classic.css">
  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="https://psuvtk.github.io/images/favicon.ico" />

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://psuvtk.github.io/">
  
    <div id="logo" style="background-image: url(https://psuvtk.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>Early is on Time</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#"><i class="fas fa-bars fa-2x"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/algo">Algo</a></li>
      
        <li><a href="/life">Life</a></li>
      
        <li><a href="/posts">Writings</a></li>
      
        <li><a href="/about">About Me</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <p>不管读字符还是读字符串都用%s来读取</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 读取 I abc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> op[<span style="color:#ae81ff">2</span>];
scanf(<span style="color:#e6db74">&#34;%s%s&#34;</span>, op, str);
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
vector    <span style="color:#960050;background-color:#1e0010">支持</span>[]
    size()
    empty()
    clear()   <span style="color:#960050;background-color:#1e0010">清空</span>
    front()<span style="color:#f92672">/</span>back()   <span style="color:#960050;background-color:#1e0010">数组头尾元素</span>
    push_back()<span style="color:#f92672">/</span>pop_back
    begin()<span style="color:#f92672">/</span>end()   <span style="color:#960050;background-color:#1e0010">首尾元素</span>
    <span style="color:#960050;background-color:#1e0010">支持字典序比较</span>
pair
    first   <span style="color:#960050;background-color:#1e0010">第一个元素</span>
    second   <span style="color:#960050;background-color:#1e0010">第二个元素</span>


string
    size()<span style="color:#f92672">/</span>length   <span style="color:#960050;background-color:#1e0010">返回长度</span>
    empty()
    clear()
    substr(a,b)  <span style="color:#960050;background-color:#1e0010">得到一个下标位</span>a长度位b的子字符串
    substr(a)   <span style="color:#960050;background-color:#1e0010">得到一个下表为</span>a长度取最长的子字符串
    c_str()   <span style="color:#960050;background-color:#1e0010">取</span>string定义数组的首地址


queue
    size()
    empty()
    push()   <span style="color:#960050;background-color:#1e0010">在队尾插入一个元素</span>
    front()<span style="color:#f92672">/</span>back()   <span style="color:#960050;background-color:#1e0010">返回队头</span><span style="color:#f92672">/</span><span style="color:#960050;background-color:#1e0010">队尾元素</span>
    pop()   <span style="color:#960050;background-color:#1e0010">弹出队头元素</span>


priority_queue <span style="color:#960050;background-color:#1e0010">优先队列</span>(<span style="color:#960050;background-color:#1e0010">堆</span>) <span style="color:#960050;background-color:#1e0010">默认大根堆</span>
    size()
    empty()
    push()
    top()
    pop()
    <span style="color:#960050;background-color:#1e0010">定义小根堆</span><span style="color:#f92672">:</span> priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span> , vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> , greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>


stack    
    size()
    empty()
    push()
    pop()
    top()


deque       <span style="color:#960050;background-color:#1e0010">支持</span>[]
    size()
    empty()
    clear()
    front()<span style="color:#f92672">/</span>back()   <span style="color:#960050;background-color:#1e0010">头尾元素</span>
    push_back()<span style="color:#f92672">/</span>push_front()   <span style="color:#960050;background-color:#1e0010">在头尾插入</span>
    begin()<span style="color:#f92672">/</span>end()



set , map , multimap , multiset , <span style="color:#960050;background-color:#1e0010">基于平衡二叉树</span> (<span style="color:#960050;background-color:#1e0010">红黑树</span>) <span style="color:#960050;background-color:#1e0010">维护一个有序数列</span> <span style="color:#960050;background-color:#1e0010">大部分函数时间复杂度都是</span>logn (<span style="color:#960050;background-color:#1e0010">因为是树</span>)
    size()
    empty()
    clear()
    begin()<span style="color:#f92672">/</span>end()  <span style="color:#960050;background-color:#1e0010">支持</span><span style="color:#f92672">++</span> <span style="color:#f92672">--</span> <span style="color:#960050;background-color:#1e0010">时间复杂度</span> O(logn)
    lower_bound()<span style="color:#f92672">/</span>upper_bound()
    lower_bound(x)     <span style="color:#960050;background-color:#1e0010">返回一个大于等于</span>x的最小值
    upper_bound(x)     <span style="color:#960050;background-color:#1e0010">返回一个大于</span>x的最小值


    set <span style="color:#f92672">/</span> multiset    set不支持重复数插入 <span style="color:#960050;background-color:#1e0010">插入重复数直接跳过</span>
        insert()    <span style="color:#960050;background-color:#1e0010">插入一个数</span>
        find()      <span style="color:#960050;background-color:#1e0010">查找一个数</span>
        count()     <span style="color:#960050;background-color:#1e0010">返回一个数存入的个数</span>
        erase()
            (<span style="color:#ae81ff">1</span>) <span style="color:#960050;background-color:#1e0010">输入是一个</span>x , <span style="color:#960050;background-color:#1e0010">删除全部</span>x , <span style="color:#960050;background-color:#1e0010">时间复杂度</span> O(k <span style="color:#f92672">+</span> logn)
            (<span style="color:#ae81ff">2</span>) <span style="color:#960050;background-color:#1e0010">输入是一个迭代器</span> , <span style="color:#960050;background-color:#1e0010">删除这个迭代器</span>

    map <span style="color:#f92672">/</span> multimap
        insert()    <span style="color:#960050;background-color:#1e0010">插入的是一个</span>pair
        erase()     <span style="color:#960050;background-color:#1e0010">输入的参数是</span>pair <span style="color:#960050;background-color:#1e0010">或者</span> <span style="color:#960050;background-color:#1e0010">迭代器</span>
        find()
        <span style="color:#960050;background-color:#1e0010">支持</span>[]



unordered_set , unordered_map , unordered_multiset , unordered_multimap
    <span style="color:#960050;background-color:#1e0010">基本跟上面一个一样</span> <span style="color:#960050;background-color:#1e0010">查找删改时间复杂度是</span> O(<span style="color:#ae81ff">1</span>)
    <span style="color:#960050;background-color:#1e0010">不支持</span>lower_bound()<span style="color:#f92672">/</span>upper_bound()  <span style="color:#960050;background-color:#1e0010">迭代器的</span><span style="color:#f92672">++</span> <span style="color:#f92672">--</span>



bitset   <span style="color:#960050;background-color:#1e0010">压位</span>
    bitset<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">放大小</span><span style="color:#f92672">&gt;</span> s;   <span style="color:#960050;background-color:#1e0010">初始化时候全为</span><span style="color:#ae81ff">0</span>  <span style="color:#960050;background-color:#1e0010">——</span> false;
    <span style="color:#f92672">~</span><span style="color:#960050;background-color:#1e0010">取反</span>  <span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">且</span>  <span style="color:#f92672">|</span><span style="color:#960050;background-color:#1e0010">或</span>  <span style="color:#f92672">^</span><span style="color:#960050;background-color:#1e0010">异或</span>
    <span style="color:#f92672">==</span> , <span style="color:#f92672">!=</span>
    <span style="color:#960050;background-color:#1e0010">移位</span> <span style="color:#f92672">&lt;&lt;</span>   <span style="color:#f92672">&gt;&gt;</span>
    <span style="color:#960050;background-color:#1e0010">支持</span>[]

    count()     <span style="color:#960050;background-color:#1e0010">返回有多少个</span><span style="color:#ae81ff">1</span>

    any()       <span style="color:#960050;background-color:#1e0010">判断是否有</span><span style="color:#ae81ff">1</span>
    none()      <span style="color:#960050;background-color:#1e0010">判断是否全为</span><span style="color:#ae81ff">0</span>

    set()       <span style="color:#960050;background-color:#1e0010">把所有位置为</span><span style="color:#ae81ff">1</span>
    set(k,v)    <span style="color:#960050;background-color:#1e0010">将第</span>k位变成v
    reset()     <span style="color:#960050;background-color:#1e0010">把所有位置为</span><span style="color:#ae81ff">0</span>
    flip()      <span style="color:#960050;background-color:#1e0010">等价于</span><span style="color:#f92672">~</span>
    flip(x)     <span style="color:#960050;background-color:#1e0010">第</span>k位取反

<span style="color:#960050;background-color:#1e0010">作者：</span>yxc_助手1387号
<span style="color:#960050;background-color:#1e0010">链接：</span>https:<span style="color:#75715e">//www.acwing.com/solution/content/90205/
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">来源：</span>AcWing
<span style="color:#960050;background-color:#1e0010">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span>
</code></pre></div>
  
  </div>
</article>


    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2023  Early is on Time 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/algo">Algo</a></li>
         
        <li><a href="/life">Life</a></li>
         
        <li><a href="/posts">Writings</a></li>
         
        <li><a href="/about">About Me</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
